'use strict';
var test = require('tape');
var res = require('./test-resources');
var parser = require('../../scripts/parser');
var sinon = require('sinon');

function helperAssertNoMessageStart(str, t) {
  var match = parser.getMessageStartIdx(str);
  t.equal(match, -1);
  t.end();
}

function helperAssertSniffJson(str, expected, t, leaveActive) {
  var actual = parser.sniffJson(str);
  t.deepEqual(actual, expected);
  // Leaving active so that if callers don't pass it, assume end.
  if (!leaveActive) {
    t.end();
  }
}

function testExtractHelper(str, indices, expected, t) {
  // Save this so we can restore state
  var originalFn = parser.findMessageStarts;

  parser.findMessageStarts = sinon.stub().returns(indices);
  var actual = parser.extractMessages(str);

  t.deepEqual(actual, expected);
  parser.findMessageStarts = originalFn;
  t.end();
}

test('readLines works on empty string', function(t) {
  // This is the default behavior. No reason to change this I don't think...
  var expected = [''];
  var actual = parser.readLines('');
  t.deepEqual(actual, expected);
  t.end();
});

test('readLines works on basicLines.txt', function(t) {
  // We're hardcoding these values.
  var expected = [
    'this is a file for',
    'testing',
    'basic line parsing',
    '',
    '12345 1',
    '12:34',
    ''
  ];

  res.getBasicLines().then(raw => {
    var actual = parser.readLines(raw);
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('findMessageStarts handles empty string', function(t) {
  var actual = parser.findMessageStarts('');
  var expected = [];
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles no matches', function(t) {
  var actual = parser.findMessageStarts('this aint no match');
  var expected = [];
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles single match at start', function(t) {
  var str = '12/25/14, ';
  var expected = [0];
  var actual = parser.findMessageStarts(str);
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles whatsapp1.txt', function(t) {
  res.getWhatsappChat1Str().then(str => {
    var actual = parser.findMessageStarts(str);
    // These were generated by running the function and making sure the output
    // looks correct. Possible there's something nefarious lurking in there
    // that I missed.
    var expected = [0, 37, 212, 397, 570];
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('findMessageStarts handles whatsapp2.txt', function(t) {
  res.getWhatsappChat2Str().then(str => {
    var actual = parser.findMessageStarts(str);
    // These were generated by running the function and making sure the output
    // looks correct. Possible there's something nefarious lurking in there
    // that I missed.
    var expected = [0, 37, 157, 341, 513];
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('getMessageStartIdx matches one line', function(t) {
  var str = '2/23/16, 12:45 PM - Sam Sudar: Prueba';
  var actual = parser.getMessageStartIdx(str);
  t.equal(actual, 0);
  t.end();
});

test('getMessageStartIdx matches across lines', function(t) {
  var str =
    'No Modificar:\n----\n{"f":"b","d":"258","m":23,"d":02}\n4/6/16, 4:19 PM';
  var expected = 52;
  var actual = parser.getMessageStartIdx(str);
  t.equal(actual, expected);
  t.end();
});

test('getMessageStartIdx ignores /12/25, 4:19 PM', function(t) {
  var str = '/12/25, 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 12/12/25 4:19 PM', function(t) {
  var str = '/12/25 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 12/12/25,4:19 PM', function(t) {
  var str = '/12/25,4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 1/25, 4:19 PM', function(t) {
  var str = '1/25, 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('extractMessages returns correct no spaces', function(t) {
  var start = 'foobarbaz';
  var indices = [0, 3, 6];
  var expected = ['foo', 'bar', 'baz'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages returns correct with spaces', function(t) {
  var start = 'foo bar baz';
  var indices = [0, 4, 8];
  var expected = ['foo ', 'bar ', 'baz'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages returns correct with newline', function(t) {
  var start = 'banana fofana\nwhoops';
  var indices = [0, 7, 14];
  var expected = ['banana ', 'fofana\n', 'whoops'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for no matches', function(t) {
  var start = 'whoop hopp hwop';
  var indices = [];
  var expected = [];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for single match', function(t) {
  var start = 'abcdefgh';
  var indices = [2];
  var expected = ['cdefgh'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for two matches', function(t) {
  var start = 'cat dog';
  var indices = [1, 4];
  var expected = ['at ', 'dog'];

  testExtractHelper(start, indices, expected, t);
});

test('sniffJson empty string null', function(t) {
  helperAssertSniffJson('', null, t);
});

test('sniffJson regular string null', function(t) {
  var str = 'hello this is a cat';
  helperAssertSniffJson(str, null, t);
});

test('sniffJson pure json.stringify', function(t) {
  var obj = {foo: 'bar', num: 14};
  helperAssertSniffJson(JSON.stringify(obj), obj, t);
});

test('sniffJson json.stringify with leading text', function(t) {
  var obj = { uhoh: 'hooray there', cat: 'hates dogs'};
  var space = 'and then a ' + JSON.stringify(obj);
  var noSpace = 'and then a' + JSON.stringify(obj);

  helperAssertSniffJson(space, obj, t, true);
  helperAssertSniffJson(noSpace, obj, t, true);
  t.end();
});

test('sniffJson json.stringify with trailing text', function(t) {
  var obj = {bar: 'baz'};
  var space = JSON.stringify(obj) + ' no space';
  var noSpace = JSON.stringify(obj) + 'no space';

  helperAssertSniffJson(space, obj, t, true);
  helperAssertSniffJson(noSpace, obj, t, true);
  t.end();
});

test('sniffJson json.stringify with leading and trailing text', function(t) {
  var obj = {itty: 'bitty', evil: 'knevil', cacique: 2};
  var objStr = JSON.stringify(obj);
  var space = 'and then ' + objStr + ' no cat';
  var noSpace = 'and then' + objStr + 'no cat';
  
  helperAssertSniffJson(space, obj, t, true);
  helperAssertSniffJson(noSpace, obj, t, true);
  t.end();
});

test('sniffJson example mdr message', function(t) {
  var str = '2/24/16, 2:40 PM - Sam Sudar: Hola Doctor, tengo nuevo bébe! ' +
    'Es de madre con DNI 10288626, y dio a luz el día 23 del mes 09.\n\n' +
    'No Modificar:\n' +
    '----\n' +
    '{"f":"b","d":"10288626","m":23,"day":9}';
 
  var expected = {
    f: 'b',
    d: '10288626',
    m: 23,
    day: 9
  };

  helperAssertSniffJson(str, expected, t);
});

test('sniffJson leading {', function(t) {
  var obj = {any: 'thing', every: 1};
  var objStr = JSON.stringify(obj);

  var a = '{' + objStr;
  var b = '{ ' + objStr;

  helperAssertSniffJson(a, obj, t, true);
  helperAssertSniffJson(b, obj, t, true);
  t.end();
});

test('sniffJson with new line', function(t) {
  var obj = { uhoh: 'hooray there', cat: 'new\nline dog'};
  var objStr = JSON.stringify(obj);

  helperAssertSniffJson(objStr, obj, t);
});

test('sniffJson empty object', function(t) {
  // {} { } {   }
  helperAssertSniffJson('{}', {}, t, true);
  helperAssertSniffJson('{}', {}, t, true);
  helperAssertSniffJson('{ }', {}, t, true);
  helperAssertSniffJson('{    }', {}, t, true);
  helperAssertSniffJson(' { } ', {}, t, true);
  t.end();
});

test('sniffJson fails in known failure case', function(t) {
  // We know we're not set up to handle something like {{{{{{{{{{{{{foo: 1}, so
  // just make sure we're handling failure gracefully.
  var obj = {foo: 'bar'};
  var str = '{'.repeat(100) + JSON.stringify(obj);
  helperAssertSniffJson(str, null, t);
});

test('tryToParse succeeds', function(t) {
  var obj = {foo: 1, bar: 'baz'};
  var str = JSON.stringify(obj);
  var actual = parser.tryToParse(str);
  t.deepEqual(actual, obj);
  t.end();
});

test('tryToParse fails', function(t) {
  var str = 'kitty doggy';
  var actual = parser.tryToParse(str);
  t.deepEqual(actual, null);
  t.end();
});
