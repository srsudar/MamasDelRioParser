'use strict';
var test = require('tape');
var res = require('./test-resources');
var parser = require('../../scripts/parser');
var sinon = require('sinon');

function helperAssertNoMessageStart(str, t) {
  var match = parser.getMessageStartIdx(str);
  t.equal(match, -1);
  t.end();
}

function testExtractHelper(str, indices, expected, t) {
  // Save this so we can restore state
  var originalFn = parser.findMessageStarts;

  parser.findMessageStarts = sinon.stub().returns(indices);
  var actual = parser.extractMessages(str);

  t.deepEqual(actual, expected);
  parser.findMessageStarts = originalFn;
  t.end();
}

test('readLines works on empty string', function(t) {
  // This is the default behavior. No reason to change this I don't think...
  var expected = [''];
  var actual = parser.readLines('');
  t.deepEqual(actual, expected);
  t.end();
});

test('readLines works on basicLines.txt', function(t) {
  // We're hardcoding these values.
  var expected = [
    'this is a file for',
    'testing',
    'basic line parsing',
    '',
    '12345 1',
    '12:34',
    ''
  ];

  res.getBasicLines().then(raw => {
    var actual = parser.readLines(raw);
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('findMessageStarts handles empty string', function(t) {
  var actual = parser.findMessageStarts('');
  var expected = [];
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles no matches', function(t) {
  var actual = parser.findMessageStarts('this aint no match');
  var expected = [];
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles single match at start', function(t) {
  var str = '12/25/14, ';
  var expected = [0];
  var actual = parser.findMessageStarts(str);
  t.deepEqual(actual, expected);
  t.end();
});

test('findMessageStarts handles whatsapp1.txt', function(t) {
  res.getWhatsappChat1Str().then(str => {
    var actual = parser.findMessageStarts(str);
    // These were generated by running the function and making sure the output
    // looks correct. Possible there's something nefarious lurking in there
    // that I missed.
    var expected = [0, 37, 211, 395, 567];
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('findMessageStarts handles whatsapp2.txt', function(t) {
  res.getWhatsappChat2Str().then(str => {
    var actual = parser.findMessageStarts(str);
    // These were generated by running the function and making sure the output
    // looks correct. Possible there's something nefarious lurking in there
    // that I missed.
    var expected = [0, 37, 157, 341, 513];
    t.deepEqual(actual, expected);
    t.end();
  });
});

test('getMessageStartIdx matches one line', function(t) {
  var str = '2/23/16, 12:45 PM - Sam Sudar: Prueba';
  var actual = parser.getMessageStartIdx(str);
  t.equal(actual, 0);
  t.end();
});

test('getMessageStartIdx matches across lines', function(t) {
  var str =
    'No Modificar:\n----\n{"f":"b","d":"258","m":23,"d":02}\n4/6/16, 4:19 PM';
  var expected = 52;
  var actual = parser.getMessageStartIdx(str);
  t.equal(actual, expected);
  t.end();
});

test('getMessageStartIdx ignores /12/25, 4:19 PM', function(t) {
  var str = '/12/25, 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 12/12/25 4:19 PM', function(t) {
  var str = '/12/25 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 12/12/25,4:19 PM', function(t) {
  var str = '/12/25,4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('getMessageStartIdx ignores 1/25, 4:19 PM', function(t) {
  var str = '1/25, 4:19 PM';
  helperAssertNoMessageStart(str, t);
});

test('extractMessages returns correct no spaces', function(t) {
  var start = 'foobarbaz';
  var indices = [0, 3, 6];
  var expected = ['foo', 'bar', 'baz'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages returns correct with spaces', function(t) {
  var start = 'foo bar baz';
  var indices = [0, 4, 8];
  var expected = ['foo ', 'bar ', 'baz'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages returns correct with newline', function(t) {
  var start = 'banana fofana\nwhoops';
  var indices = [0, 7, 14];
  var expected = ['banana ', 'fofana\n', 'whoops'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for no matches', function(t) {
  var start = 'whoop hopp hwop';
  var indices = [];
  var expected = [];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for single match', function(t) {
  var start = 'abcdefgh';
  var indices = [2];
  var expected = ['cdefgh'];

  testExtractHelper(start, indices, expected, t);
});

test('extractMessages for two matches', function(t) {
  var start = 'cat dog';
  var indices = [1, 4];
  var expected = ['at ', 'dog'];

  testExtractHelper(start, indices, expected, t);
});
